####
### R script by Ivan Prates (ivanprates.org).
### University of Michigan, Ann Arbor, MI, USA.
### May 2020.

### The goals of this script are:
### To run genetic clustering analyses using sNMF;
### To make bar plots based on the ancestry coefficients.

## PART 1: Getting ready: ----

## Installing LEA:
## Using BiocManager:
#install.packages("BiocManager")
#library(BiocManager)
#BiocManager::install(version = "3.10")
#BiocManager::install("LEA")

## Installing other packages we'll need:
## For analyses and plotting:
#install.packages("cowplot")
#install.packages("ggrepel")
#install.packages("here")
#install.packages("imgpalr")
#install.packages("magrittr")
#install.packages("phytools")
#install.packages("png")
#install.packages("tidyverse")

## For the maps:
#install.packages("rgeos")
#install.packages("rnaturalearth")
#install.packages("rnaturalearthdata")
#install.packages("sf")

## Loading packages:
## For analyses and plotting:
library(cowplot)
library(here)
library(imgpalr)
library(LEA)
library(magrittr)
library(phytools)
library(png)
library(tidyverse)

## For the maps:
library(ggrepel)
library(rgeos)
library(rnaturalearth)
library(rnaturalearthdata)
library(sf)

## PART 2: Running genetic clustering analyses using sNMF: ----

## Create function to run sNMF and prepare the results for plotting:
run_sNMF <- function(mid, ms, a){

  ## Reading genetic data:  
  ## Missing sites should be coded as 9! Don't forget to replace -1 to 9 if using VCF Tools.
  gendata <- read.table(paste0(here(), "/VCFtools/", ipyrad_run, "/mac", mac, "/mid", mid, "/ms", ms, "/ms", ms, ".usnps.012"), sep = "\t", row.names = 1)
  #dim(gendata)

  ## Writing down data in LFMM format (LEA saves it all outside R, instead of as objects):
  #write.geno(gendata, paste0("mid", mid, "_ms", ms, "_a", a, ".geno"))

  ## Running sNMF:
  #project.snmf <- snmf(paste0("mid", mid, "_ms", ms, "_a", a, ".geno"), K = minK:maxK, seed = 20191209, CPU = cpu,
  #                     entropy = TRUE, ploidy = 2, alpha = a, repetitions = r, project = "new")
  
  ## Loading previously saved sNMF project:
  project.snmf <- load.snmfProject(paste0("mid", mid, "_ms", ms, "_a", a, ".snmfProject"))
  
  ## Showing summary of project results:
  snmf_summary <- summary(project.snmf)
  #snmf_summary
  
  ## Selecting criterion to determine the best K:
  crossEntropy <- snmf_summary$crossEntropy[2,] # Using mean cross entropy across runs.
  crossEntropy <- format(round(crossEntropy, digits = 5), nsmall = 5) # Rounding digits.
  
  ## Selecting best K based on minimum (or mean) cross entropy among runs:
  bestK <- names(which.min(crossEntropy))
  bestK %<>% gsub(pattern = "K = ", replacement = "", .) # removes gaps from sequences. "." denotes object when using "%<>%"
  bestK <- as.integer(bestK)
  #bestK ## View best K.
  
  ## Setting a couple variables to help us name outputs down the road:
  minentropy <- min(crossEntropy)
  
  ## Preparing x axis for cross-entropy plot:
  CEnames <- gsub(x = names(crossEntropy), pattern = "K = ", replacement = "")
  
  ## Plotting mean entropy scores:
  png(filename = paste0(here(), "/LEA/", ipyrad_run, "/mac" , mac, "/sNMF_plots/mid", mid, "_ms", ms, "/mid", mid, "_ms", ms, "_a", a, "_e", minentropy, "_K", bestK, ".png"))
  plot(y = crossEntropy, x = CEnames, cex = 1.2, col = "blue", pch = 19, xlab = "Number of genetic clusters (K)", ylab = "Cross-entropy scores")
  lines(y = crossEntropy, x = CEnames, col = "blue")
  dev.off() # Saving plot as .png image.
  
  ## Creating empty lists to populate with matrices of qscores:
  qmatrix_list <- vector("list", length(minK:maxK))
  
  ## Creating empty lists to populate with matrices of qscores:
  qmatrix_molten_list <- vector("list", length(minK:maxK))
  
  ## Extracting qmatrix for some K:
  for (K in minK:maxK){
  
    ## Getting the cross entropy of all runs for K = best K:
    ce <- cross.entropy(project.snmf, K = K)
    ce <- format(round(ce, digits = 6), nsmall = 6)
    
    ## Selecting the run with the lowest cross-entropy for K = best K:
    bestrun <- which.min(ce)
    
    ## Getting the Q matrix for the best run and K:
    qmatrix <- Q(project.snmf, K = K, run = bestrun)
    qmatrix <- as.data.frame(qmatrix)
    colnames(qmatrix) <- c(paste0(rep("Cluster_", K), 1:K)) # Change column names for cluster name. Will repeat "cluster" K times, then paste0 with second element from 1 to K times.
  
    ## Adding individual ID names for plotting:
    ## We'll read a list of sample IDs generated by VCFtools.
    individuals <- read.table(file = paste0(here(), "/VCFtools/", ipyrad_run, "/mac" , mac, "/mid", mid, "/ms", ms, "/ms", ms, ".usnps.012.indv"))
    qmatrix$ID <- individuals$V1 # Change row names to sample IDs.
  
    ## "Melt" dataframe using the gather function so we can assign samples to clusters based on max qscores:
    qmatrix_melt <- gather(qmatrix, key = cluster_assign, value = coeff, 1:K)
    #View(qmatrix_melt) ## View data.
  
    ## Assign specimens to cluster based on the highest qscore (coeff) values:
    cluster_assign <- qmatrix_melt %>% group_by(ID) %>% top_n(n = 1, wt = coeff)
    #View(cluster_assign) ## View data.
  
    ## Combine qmatrix and cluster assignments:
    qmatrix_edited <- merge(qmatrix, cluster_assign, by = "ID")
  
    ## Rounding qscores to 2 digits:
    qmatrix_edited %<>% mutate_at(c(paste0("Cluster_", 1:K), "coeff"), round, digits = 2)
  
    ## Now let's add the position of each sample in an inferred phylogeny to guide sample order in our structure plots.
    ## Loading phylogenetic tree:
    full_tree <- read.nexus(paste0(here(),"/RAxML/ni277/RAxML_bipartitions.nex"))
  
    ## Extracting tip labels:
    ## If needed, let's only keep the individuals included in sNMF analyses.
    tip_labels <- (full_tree$tip.label[full_tree$tip.label %in% qmatrix$ID])
  
    ## Saving sample order in the phylogenetic tree:
    sample_order <- as.data.frame(tip_labels)
    colnames(sample_order) <- "ID" # Change column name to specimens' IDs.
  
    ## Adding column with consecutive numbers so we can sort by order in the tree afterwards: 
    sample_order$plot_order <- 1:nrow(sample_order)
  
    ## Merging sample order in phylogenetic tree with the edited qmatrix:
    qmatrix_edited <- merge(qmatrix_edited, sample_order, by = "ID")
  
    ## Now, let's add locality information (including lat-longs) to the qmatrix:
    sample_info_all <- read.csv(file = paste0(here(), "/sample_information/sample_info_inornatus_gr_n305.csv"), header = TRUE)
  
    ## Let's only keep the individuals included in sNMF analyses.
    sample_info <- (sample_info_all[sample_info_all$DDRAD_ID %in% qmatrix$ID, ])
    names(sample_info)[names(sample_info) == "DDRAD_ID"] = "ID" ## Renaming ID column for consistency across files.
  
    ## Merging:
    qmatrix_edited <- merge(qmatrix_edited, sample_info, by = "ID")
  
    ## Preparing data for ggplot:
    ## Order samples by plot order derived from phylogeny:
    qmatrix_edited <- arrange(qmatrix_edited, plot_order)
  
    ## Defining the order of levels of IDs and clusters in further plots
    id_levels <- sample_order$ID
    cluster_levels <- unique(qmatrix_edited$cluster_assign)
    
    ## Forcing the order of clusters to be the same as the assigned clusters according to the order in the phylogeny.
    ## This will re-define the hierarchical order of elements to be not alphabetic, but the one coming from sNMF results:
    qmatrix_edited$cluster_assign <- factor(qmatrix_edited$cluster_assign, levels = cluster_levels)
    
    ## "Melt" dataframe using the gather function, as required by ggplot:
    qmatrix_remelt <- gather(qmatrix_edited, key = sNMF_cluster, value = qscores, 2:(K+1))
    
    ## Force the order of clusters to be the same as the assigned clusters according to the order in the phylogeny:
    ## This will re-define the hierarchical order of elements to be not alphabetic, but the one coming from sNMF results.
    qmatrix_remelt$ID <- factor(qmatrix_remelt$ID, levels = id_levels)
    qmatrix_remelt$cluster_assign <- factor(qmatrix_remelt$cluster_assign, levels = cluster_levels)
    qmatrix_remelt$sNMF_cluster <- factor(qmatrix_remelt$sNMF_cluster, levels = cluster_levels)
    qmatrix_remelt
    
    ## Place resulting qmatrix in the corresponding slot:
    qmatrix_list[[K-minK+1]] <- qmatrix_edited
    
    ## Place resulting molten qmatrix in the corresponding slot:
    qmatrix_molten_list[[K-minK+1]] <- qmatrix_remelt
    
    } ## Close loop (K).
  
  ## Function will return:
  return(list(qmatrix_list = qmatrix_list,
              qmatrix_molten_list = qmatrix_molten_list,
              crossEntropy = crossEntropy[minK:maxK],
              bestK = bestK))
  
  } ## End of function.
  
## PART 3: Creating color palettes to plot ancestry coefficients for each K: ----

## Creating a function to create coor palettes:
get_color_palette <- function(minK, maxK){

  ## Let's first create an empty list to populate with color palletes for the bar plots.
  ## Each color palette will have K colors:
  palette_list <- vector("list", length(minK:maxK))
  
  ## Let's now create the color palettes for each K:
  for (K in minK:maxK){
    
  ## Same for just some K:
  #for (K in 13:15){
  
    ## For this, we'll extract colors from an image using imgpalr:
    palette_list[[K-minK+1]] <- image_pal(paste0(here(), "/color_palettes/viridis_edited.png"), 
                                          seed = 15, ## Seed of k-means cluster algorithm; changes results.
                                          type = "seq", # seq, qual, or div.
                                          n = K, ## Desired number of colors.
                                          k = 20, ## Number of k-means cluster centers used to cluster colors in original figure.
                                          saturation = c(0.05, 1), brightness = c(0.01, 1), ## Trim extremes of saturation and brightness.
                                          seq_by = "hsv", ## Sequence by hue (h), saturation (s), and brightness (v). Order can be changed.
                                          plot = TRUE, labels = TRUE) ## Show hex values on plot.

    } ## End of loop (K values).
  
  ## Function will return:
  return(palette_list = palette_list)

  } ## End of function.

## PART 4: Plotting ancestry coefficients as barplots: ----

## Creating function to plot with ggplot:
plot_sNMF_bars <- function(mid, ms, a){

  ## Plotting every K:
  for (K in minK:maxK){

  ## Plotting some K:
  #for (K in 11:15){
  
  ## Plotting only best K:
  #K <- sNMF_results$bestK
      
    ## Define qmatrix (for corresponding K value) to use:
    qmatrix_remelt <- sNMF_results$qmatrix_molten_list[[K-minK+1]]
    
    ## Extract corresponding cross-entropy score:
    crossEntropy <- sNMF_results$crossEntropy[[K-minK+1]]
    
    ## Using corresponding color palette:
    cluster_palette <- palette_list[[K-minK+1]]
    
    ## For each K, selecting list of putative taxa for plot legends:
    putative_taxa <- putative_taxa_list[[K-minK+1]]
    
    ## Creating stacked bar plot of ancestry coefficients:
    sNMF_plot <- ggplot(data = qmatrix_remelt, aes(x = ID)) +
    
    ## Adding bars that represent ancestry coefficients:
    geom_bar(aes(y = qscores, fill = sNMF_cluster), 
             color = "white", ## Color of bar lines.
             size = 0.01, ## Thickness of bar lines.
             stat = "identity", position = "fill") +
             #show.legend = FALSE) +
  
    ## Adding points that correspond to originally assigned species below bars:
    #geom_point(aes(x = ID, y = -0.02, color = SPECIES), size = 2) +
  
    ## Adding dark empty circles that will encircle the points that show species:
    #geom_point(aes(x = ID, y = -0.02), shape = 21, color = "black", size = 2) +
    #guides(color = FALSE) +
    
    ## Filling bars by cluster assigment:
    scale_fill_manual("Clusters:", values = cluster_palette, labels = putative_taxa) + 
    
    ## Filling circles by species:
    #scale_color_manual(values = species_palette, guide = "none") +
  
    ## Adjusting labels:
    labs(y = "Ancestry coefficient", x = "") +
    
    ## Adjusting limits of the y axis:
    scale_y_continuous(limits = c(-0.03,1), expand = c(0,0)) +
      
    ## Changing overall font size:
    theme_minimal(base_size = 20) +
    
    ## Setting overall title:
    ggtitle(label = expression(paste(italic("Ctenotus inornatus"), " species group:")),
            subtitle = paste0("sNMF genetic clusters (K = ", K, ")")) +
    
    ## Changing theme parameters:
    theme(
  
          ## Adding individual IDs below bars:  
          #axis.text.x = element_text(angle = 270, hjust = 0, vjust = 0.5, size = 7, margin = margin(-1.5, 0, 0, 0)),
          axis.text.x = element_blank(), ## Removing IDs from plot.
    
          ## Adjusting other parameters:
          panel.grid.major.x = element_blank(),
          panel.grid = element_blank(), 
          axis.text.y = element_text(angle = 0, margin = margin(0, 0, 0, 0)),
          plot.margin = unit(c(t = 0.75, r = 0.75, b = 0.75, l = 0.75),"cm"),
          plot.title = element_text(hjust = 0.5, size = 22),
          plot.subtitle = element_text(hjust = 0.5, size = 26,
                                       margin = margin(t = 1, r = 0, b = 20, l = 0)))
  
    ## Saving plot:
    save_plot(plot = sNMF_plot, base_width = 30, base_height = 5,
              filename = paste0(here(), "/LEA/", ipyrad_run, "/mac" , mac, "/sNMF_plots/mid", mid, "_ms", ms, 
                                "/mid", mid, "_ms", ms, "_a", a, "_e", crossEntropy, "_K", K, ".jpeg"))
         
    } ## End of loop (K values).
    
  } ## End of function.
     
## PART 5: Plotting maps: ----

## Now creating a function to plot maps with ggplot:
plot_maps <- function(mid, ms, a){
  
  ## Let's start by setting up a few map features.
  ## Importing world map:
  world <- ne_countries(scale = "medium", returnclass = "sf")
  
  ## Selecting the part that represents Australia:
  AUS <- filter(world, admin == "Australia")
  
  ## Restrict geographic area using a box:
  bbox <- st_bbox(AUS)
  bbox[["ymin"]] = -40
  bbox[["xmax"]] = 153
  
  ## Plotting for every K:
  for (K in minK:maxK){
  
  ## Plotting for some K:
  #for (K in 11:15){
  
  ## Plotting only best K:
  #K <- sNMF_results$bestK
    
    ## Define qmatrix (for corresponding K value) to use:
    qmatrix <- sNMF_results$qmatrix_list[[K-minK+1]]
    
    ## Extract corresponding cross-entropy score:
    crossEntropy <- sNMF_results$crossEntropy[[K-minK+1]]
    
    ## Using corresponding color palette:
    cluster_palette <- palette_list[[K-minK+1]]
    
    ## For each K, selecting list of putative taxa for plot legends:
    putative_taxa <- putative_taxa_list[[K-minK+1]]
    
    ## Change facet plot titles to putative taxa:
    levels(qmatrix$cluster_assign) <- putative_taxa
    
    ## Plot map with ggplot:
    map_clusters <- ggplot() +
    
      ## Adding baseline map:
      geom_sf(data = world, fill = "gray95", color = "gray60") +
      
      ## Adding ID labels on top of map:
      #geom_text(data = qmatrix_ord, aes(x = longitude, y = latitude, label = ID) ) +
      #geom_text_repel(data = qmatrix, aes(x = LON, y = LAT, label = SPECIES)) + ## Using repel to avoid overlapping labels.
      
      ## Adding lat-longs for sampled individuals:
      geom_point(data = qmatrix, aes(x = LON, y = LAT, fill = cluster_assign), 
                 shape = 21, size = 3, alpha = 0.95, color = "black") +
      
      ## Set map boundaries:
      coord_sf(xlim = bbox[c("xmin", "xmax")],
               ylim = bbox[c("ymin", "ymax")]) +
      
      ## Setting a bunch of aesthetic parameters:
      theme_void() +
      guides(fill = "none") +
      scale_fill_manual(values = cluster_palette) +
      labs(x = "", y = "") +
      
      ## Setting up facets by cluster:
      facet_wrap(~cluster_assign, ncol = 4) +
                 
      ## Setting overall title:
      ggtitle(label = expression(paste(italic("Ctenotus inornatus"), " species group:")),
              subtitle = paste0("Spatial distribution of genetic clusters (K = ", K, ")")) +
      
      ## Setting some other elements:
      theme(panel.background = element_rect(fill = "aliceblue"),
            panel.border = element_rect(fill = NA),
            strip.text = element_text(size = 15),
            strip.background = element_rect(fill = "transparent"),
            plot.margin = unit(c(t = 0.25, r = 0.5, b = 0.25, l = 0.5),"cm"),
            plot.title = element_text(hjust = 0.5, size = 18,
                                      margin = margin(t = 0, r = 0, b = 1, l = 0)), 
            plot.subtitle = element_text(hjust = 0.5, size = 20,
                                         margin = margin(t = 5, r = 0, b = 15, l = 0))) ## Margin around plot.
            
    ## Saving plot:
    save_plot(plot = map_clusters, base_width = 10, base_height = 10,
              filename = paste0(here(), "/LEA/", ipyrad_run, "/mac" , mac, "/sNMF_maps/mid", mid, "_ms", ms, 
                                "/mid_", mid, "_ms", ms, "_a", a, "_e", crossEntropy, "_K", K, "_map.jpeg"))
            
    } ## Close loop (K values).
    
 } ## End of function.
 
## PART 6: Running all functions that we created: ----

## Setting a few parameters for the analyses:
#r <- 50 ## Number of replicates for each K value.
#cpu <- 8 ## Number of threads to use.
ipyrad_run <- "inornatus_gr_c90_ni281_mi070" ## Output files from ipyrad.

## Setting minimum allele count (mac):
for (mac in c(2)){

  ## If needed, remove existing folder to start again from scratch:
  #unlink(paste0(here(), "/LEA/", ipyrad_run,"/mac" , mac), recursive = TRUE)
  
  ## Creating a directory to place LEA results:
  dir.create(here("LEA"))
  
  ## Creating a directory to place sNMF results:
  dir.create(paste0(here(), "/LEA/", ipyrad_run))
  dir.create(paste0(here(), "/LEA/", ipyrad_run, "/mac", mac))
  
  ## Creating subfolders to place sNMF results:
  for (dir in c("analyses", "maps", "plots", "workspaces")){
    dir.create(paste0(here(), "/LEA/", ipyrad_run, "/mac" , mac, "/sNMF_", dir))}
  
  ## Setting working directory:
  setwd(paste0(here(), "/LEA/", ipyrad_run, "/mac" , mac, "/sNMF_analyses"))
      
  ## Applying function to create color palettes:
  palette_list <- get_color_palette(minK = minK, maxK = maxK)
  
  ## For the other functions we'll use combinations of parameters:
  for (mid in c(0.8)){ ## Level of missing data per sample.
    for (ms in c(0.35)){ ## Level of missing data per SNP.
      
      ## Creating directories to place sNMF results:
      dir.create(paste0(here(), "/LEA/", ipyrad_run, "/mac" , mac, "/sNMF_plots/mid", mid, "_ms", ms))
      dir.create(paste0(here(), "/LEA/", ipyrad_run, "/mac" , mac, "/sNMF_maps/mid", mid, "_ms", ms))
      
      ## Regularization multiplier (alpha) for sNMF:
      for (a in c(500)){
        
        ## Applying function to run sNMF:
        sNMF_results <- run_sNMF(mid = mid, ms = ms, a = a)
    
        ## Applying function to plot ancestry coefficients:
        plot_sNMF_bars(mid = mid, ms = ms, a = a)
  
        ## Applying function to plot maps:
        plot_maps(mid = mid, ms = ms, a = a)
   
      ### Close loops:
      }}}}
      
## PART 7: Wrapping up: ----

## Saving our progress as an R workspace image:
save.image(file = paste0(here(), "/LEA/", ipyrad_run, "/mac" , mac, "/sNMF_workspaces/mid", mid, "_ms", ms, "_a", a, ".RData"))

## End of script.
